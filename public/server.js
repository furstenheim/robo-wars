(function(){'use strict';/* Shared variables and global js variables (better here than global so they can be minified */// TODO move this to client so there are no conflicts
//var socket
// global variable
function a(n){return JSON.parse(JSON.stringify(n))}// Half PI
// Use complex to rotate, move on the plane
function b(n,o){return Array.isArray(n)?b(n[0],n[1]):{x:n,y:o}}// No method overloadin :(
var f={},l=['ArrowRight','ArrowUp','ArrowLeft','ArrowDown'],m=Math.PI/2;f.Actions={init:function(){return{players:[]}},types:{player:'player',laser:'laser',death:'death',win:'win'}},b.add=function(n,o){return new b(n.x+o.x,n.y+o.y)},b.multiply=function(n,o){return new b(n.x*o.x-n.y*o.y,n.x*o.y+n.y*o.x)},b.getTheta=function(n){return 0===n.x?1===n.y?1*m:3*m:1===n.x?0:2*m},f.Game={init:function(){return{// TODO move this to client
h:1000,w:1500,sx:30,sy:20,np:f.Game.np}},get np(){return 2},prepareGame:function(n){var o,p,r,q=['floor','wall'],s=[],t=[],u=[0,0.5,0.99,0.5],v=[0.5,0,0.5,0.99],z=[[1,0],[0,1],[-1,0],[0,-1]],A=[],B=[];for(o=0;o<n.np;o++){let C=~~(u[o]*n.sx),D=~~(v[o]*n.sy);A.push(C),B.push(D),t.push(f.Player.init(b(C,D),'player'+o,b(z[o]),1,f.Player.statuses.alive))}for(o=0;o<n.sx;o++)for(p=0;p<n.sy;p++){r=q[0.85>Math.random()?0:1];for(let C=0;C<A.length;C++)2.5>Math.abs(o-A[C])+Math.abs(p-B[C])&&(r=q[0]);s.push(f.Tile.init(o,p,r))}return{game:n,players:t,tiles:s,remainingActions:[],postActions:[]}},computeMovements(n,o){// We compute the resulting positions and actions and that is what we pass to the users, as the tiles they already know
var s,p=a(n),q=[],r=p.players;for(let t of o){// ohh my old node without json destructuring
let u=t.position;// dead are not allowed to move
if(r[u].s!==f.Player.statuses.dead){let J=f.Player.handleAction(r[u],t),K={player:J.player,position:u},L=[K],M=J.direction;// Let's do all the pushing (in case we don't stumble to a wall)
if(M){for(;K=f.Game.computePlayerCollision(K.player,r,M);)L.push(K);// Compute if the movement is possible, if not we abort all movements
f.Game.computeMovementObstruction(L[L.length-1].player,p)&&(L=[{player:r[u],position:u}])}for(let Q of L)r[Q.position]=Q.player;let N=[],O=r[u];if(s=f.Game.computeLasers(O,r,p)){let Q=f.Player.decreaseHealth(s.oplayer),R=r[s.oposition].s===f.Player.statuses.alive&&Q.s===f.Player.statuses.dead;if(r[s.oposition]=Q,N.push(Object.assign(s,{oplayer:Q})),R){N.push({type:f.Actions.types.death,oposition:s.oposition});for(let S=0,T=-1,U=0;U<r.length;U++)r[U].s===f.Player.statuses.dead?S++:T=U;(S=r.length-1)&&N.push({type:f.Actions.types.win,position:T})}}// TODO handle shooting
// TODO add postActions
q.push({movements:L,postActions:N})}}return{state:p,actions:q}},computePlayerCollision(n,o,p){for(let q=0;q<o.length;q++)if(f.Player.collide(n,o[q]))return{position:q,player:f.Player.move(o[q],p)}},computeMovementObstruction(n,o){// TODO check for blocks
var p=n.c,q=o.game;return 0>p.x||0>p.y||p.x>q.sx||p.y>q.sy||!('wall'!==o.tiles[q.sy*p.x+p.y].type)||void 0},computeLasers(n,o,p){var q=n;// Laser blasts up to four
for(let r=0;4>r;r++){// Nothing to shoot
if(q=f.Player.handleAction(q,{subtype:'ArrowUp'}).player,f.Game.computeMovementObstruction(q,p))return!1;for(let s=0;s<o.length;s++)if(f.Player.collide(q,o[s]))return{type:'laser',player:n,oplayer:o[s],oposition:s}}}},f.Player={init:function(n,o,p,q,r){var s=f.PlayerTile.init(n.x,n.y,o,b.getTheta(p));return{t:s,o:p,c:n,type:o,h:q,s:r}},handleAction(n,o){var p=o.subtype;return'ArrowUp'===p?{player:f.Player.move(n,n.o),direction:n.o}:'ArrowLeft'===p?{player:f.Player.init(n.c,n.type,b.multiply(n.o,{x:0,y:-1}),n.h,n.s)}:'ArrowRight'===p?{player:f.Player.init(n.c,n.type,b.multiply(n.o,{x:0,y:1}),n.h,n.s)}:'ArrowDown'===p?{player:f.Player.move(n,b.multiply({x:-1,y:0},n.o)),direction:b.multiply({x:-1,y:0},n.o)}:void 0},move(n,o){return f.Player.init(b.add(n.c,o),n.type,n.o,n.h,n.s)},collide(n,o){return n.c.x===o.c.x&&n.c.y===o.c.y},decreaseHealth(n){var o=0.93*n.h;return f.Player.init(n.c,n.type,n.o,o,0.5>o?f.Player.statuses.dead:f.Player.statuses.alive)},statuses:{dead:'dead',alive:'alive'}},f.PlayerTile={init:function(n,o,p,q){return{x:n,y:o,type:p,t:q}},changeState:function(n,o,p,q){return{x:n.x+o,y:n.y+p,type:n.type,t:n.t+q}}},f.store={},f.Tile={init:function(n,o,p){return{x:n,y:o,type:p}},render:function(n,o,p){if(p&&!o){var q=f.Game.getRealCoordinates(n,p.x,p.y),r=f.bgc,s=new Image;s.src=f.Tiles[p.type],r.drawImage(s,q.x,q.y,q.w,q.h)}}},'undefined'!=typeof window&&function(){/**
 * Bind Socket.IO and button events
 */function n(){o.on('actions',function(q){f.store.acceptActions(q)}),o.on('start',function(q){f.store.startGame(JSON.parse(q))}),o.on('end',function(){}),o.on('connect',function(){}),o.on('disconnect',function(){}),o.on('error',function(){})}var o,p=document.getElementById.bind(document);/*
g.Action = {
  init: function (type, params) {
    var action
    switch (type) {
      case 'playerMovement':
        action = g.Action.player(params)
        break
      case 'laser':

      default:
        action = {}
        break
    }
    return Object.assign(action, {type: type})
  },
  playerMovement: function (params) {
    return {
      subtype: params.type,
      player: params.player
    }
  }
}*/// Nasty trick to cache imgs and make loading sync
for(let q in Object.assign(f.Game,{// No need for this on the server
getRealCoordinates:function(q,r,s){return{x:r*q.w/q.sx,y:s*q.h/q.sy,w:q.w/q.sx,h:q.h/q.sy}}}),f.Input={init:function(){return{time:new Date,actions:[]}},size:{w:800,h:100},max:4,render:function(q,r){var s=f.Input.size.h,t=f.Input.size.w,u=f.ic,v=~~(s/30),z=s*f.Input.max+s/2,A=s/2;// For some reason circle does not disappear without c.beginPath?Â¿
u.beginPath(),u.clearRect(0,0,t,s);for(let B=0;B<f.Input.max;B++){u.strokeStyle='black',u.strokeRect(s*B+v,v,s-2*v,s-2*v);let C=q.actions[B];if(C){u.save();let D=f.images.arrow;u.translate(s*B+s/2,s/2),u.rotate(-f.Input.subtypeToTheta(C.subtype)),u.drawImage(D,-(s-2*v)/2,-(s-2*v)/2,s-2*v,s-2*v),u.restore()}}r=Math.max(Math.min(r,1),0),0<r&&(u.beginPath(),u.fillStyle='red',u.moveTo(z,A),u.arc(z,A,A-2*v,0,4*r*m),u.lineTo(z,A),u.closePath(),u.fill()),u.stroke()},clear:function(){var q=f.Input.size.h,r=f.Input.size.w,s=f.ic;s.clearRect(0,0,r,q)},subtypeToTheta(q){var r=l.indexOf(q);if(-1<r)return m*r},// health goes from 0 to 1 1 is healthy, remainingTime so we can prioritize
acceptAction(q,r,s,t){var u=Math.random()<s,v=a(q);return q.actions.length>=f.Input.max?q:(u?v.actions.push({type:f.Actions.types.player,subtype:r,remainingTime:t}):v.actions.push({type:f.Actions.types.player,subtype:l[~~(4*Math.random())],remainingTime:t}),v)},// Fill input to the total
fillInput(q){var s,r=a(q);for(s=q.actions.length;s<f.Input.max;s++)r.actions.push({type:f.Actions.types.player,subtype:l[~~(4*Math.random())],remainingTime:0});return r}},Object.assign(f.PlayerTile,{render:function(q,r,s,t){if(s){var v,z,A,B,u=f.Game.getRealCoordinates(q,s.x,s.y);if(t=Math.min(Math.max(t,0),f.store.movement)/f.store.movement,!r)v=u.x,z=u.y,A=s.t;else{var C=f.Game.getRealCoordinates(q,r.x,r.y);v=(1-t)*C.x+t*u.x,z=(1-t)*C.y+t*u.y,B=Math.abs(r.t-s.t)<2*m?r.t:Math.abs(r.t-4*m-s.t)<Math.abs(r.t+4*m-s.t)?r.t-4*m:r.t+4*m,A=(1-t)*B+t*s.t}var D=f.c;f.c.save();var E=u.w/2,F=u.h/2;f.c.translate(v+E,z+F),f.c.rotate(A);var G=f.images[s.type];D.drawImage(G,-F,-E,2*E,2*F),f.c.restore()}}}),f.store={init:function(){return{game:f.Game.init(),tiles:[],players:[],remainingActions:[],postActions:[]}},movement:1000,inputActions:4,inputTime:2000,listenInput:!1,// tick depends movement so we need this wizardy
get tick(){return this.movement/60},startGame(q){var r=f.store.state;f.store.oldState=r,f.store.state=q,f.store.render(r,q),f.store.acceptInput()},acceptInput(){if(!f.store.input&&!f.store.dead&&!f.store.won)return f.store.input=f.Input.init(),document.addEventListener('keydown',f.store.handleKeyDown,!1),window.requestAnimationFrame(f.store.acceptInput);// TODO only send necessary actions
var q=(f.store.inputTime-(new Date-new Date(f.store.input.time)))/f.store.inputTime;return 0>q?(document.removeEventListener('keydown',f.store.handleKeyDown),f.store.input=f.Input.fillInput(f.store.input),f.Input.render(f.store.input,-1),f.store.sendMovements(f.store.input.actions),void(f.store.input=!1)):void(f.Input.render(f.store.input,q),window.requestAnimationFrame(f.store.acceptInput))},acceptActions(q){var r=f.store.state,s=a(r);s.remainingActions=q,f.store.oldState=r,f.store.state=s,f.store.displayMovement()},prepareGame(){var q=f.store.state,r=a(q),s=q.game,t=f.Game.prepareGame(s);r.tiles=t.tiles,r.players=t.players,f.store.state=r,f.store.oldState=q,f.store.render(q,r)},sendMovements(q){o.emit('move',q)},render(q,r,s){f.c.clearRect(0,0,r.game.w,r.game.h);var z,t=q.tiles,u=r.tiles,v=r.game;// First go the tiles
for(z=0;z<Math.max(t.length,u.length);z++)f.Tile.render(v,t[z],u[z]);var A=q.players,B=r.players;for(z=0;z<Math.max(A.length,B.length);z++)f.PlayerTile.render(v,(A[z]||{}).t,(B[z]||{}).t,s)},displayMovement(){var q=f.store.oldState,r=f.store.state,s=r.game,t=f.store.animating,u=new Date-f.store.time;// we need to do post Actions
if(t)// Render one just time to make sure we render correctly
return u>f.store.movement&&(f.store.animating=!1),window.requestAnimationFrame(f.store.displayMovement),f.store.render(q,r,u);var B,v=a(r),z=v.remainingActions,A=v.postActions;// Handle post actions from previous movement
if(A.length){for(let C of A)f.store.handleAction(v,C);v.postActions=[]}else{// Handle actions
if(!z.length)return void f.store.acceptInput();// Prepare the actions
B=z.shift();for(let C of B.movements)Object.assign(v.players[C.position],C.player);v.postActions=B.postActions}// TODO handle postactions
f.store.oldState=r,f.store.state=v,f.store.animating=!0,f.store.time=new Date,window.requestAnimationFrame(f.store.displayMovement)},handleAction(q,r){return r.type===f.Actions.types.laser?(Object.assign(q.players[r.oposition],r.oplayer),void f.store.renderHealth(q.players)):r.type===f.Actions.types.death?void f.store.handleDeath(r.oposition,q):void(r.type===f.Actions.types.win&&f.store.handleWin(r.position,q))},handleKeyDown(q){var r=q.key||q.code,s=f.store.input,t=a(s),u=(f.store.inputTime-(new Date-new Date(f.store.input.time)))/f.store.inputTime;-1!==l.indexOf(r)&&(f.store.input=f.Input.acceptAction(s,r,1,u))},renderHealth(q){var s,r=[];for(let t=0;t<q.length;t++)s=q[t],r.push(`Player ${t} health: ${parseInt(100*(2*(Math.max(s.h,0.5)-0.5)))} %`);f.health.textContent=r.join(' ')},handleDeath(q,r){q===r.position&&(f.store.dead=!0)},handleWin(q,r){q===r.position&&(f.store.won=!0)}},Object.assign(f.Tile,{render:function(q,r,s){if(s&&!r){var t=f.Game.getRealCoordinates(q,s.x,s.y),u=f.bgc,v=f.images[s.type];u.drawImage(v,t.x,t.y,t.w,t.h)}}}),f.Tiles={},f.Tiles={floor:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AkLCTo0C01FEQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABQSURBVBjTpVBBDgAgCCr/Wr0pe0r1tw6txhJPcVNAHHGOHg6a1pRLMIgo8iAe0bS+IlxtYK7YlTWQOGsQ7w80COXI4/c+Lem7J8zlPeGYclkeyCQcEkGchAAAAABJRU5ErkJggg==',wall:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AkLChMusC+d2QAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABLSURBVBjTY7S1tWUgBJjQ+GqqqjgVweVu3b6NqY2RHOvQDIYwmLA6BW4phMEEUQEXRTMDYRKyY9HMQHcTXCtmKBDtO2TrsRpGlEkAsuEcUVru56YAAAAASUVORK5CYII=',player0:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AkLCgUEdwzh2AAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAACzSURBVCjPlZKhEoJAFEXPMmbMVhPOGMw2g4ls9gf8BnaWDFj8AbPZBIzNbDBbzewPPNMCCjpy086be3fvebOqLHKGaAQQGyNuMJ9O1Pp8YT8LpG2MtFYAXt8tebjqzGJjmhcAZW0lANdbJR9eBeD747dAR8tF4I4CcH88m0qR1j9BD8dT7fEYqL8Cu+2mASqLnNgYHHSPauhI6xpa3BasrZxB2tAu2KmUpBlJmn2tp4Z+jRd6aDOnkL7QngAAAABJRU5ErkJggg==',player1:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AkLCg8PGjHQ2gAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAB4SURBVCjPY7S3tWEgBTAxkAhYGBgYGA4ePvKfGMX2tjaMJNvACPMDi/BZFFs0VH4y3LjDDlf3560xwknoipAV793wnYGBgeE/A8MRBgYGBlQnISvWUPmJ29PYAMyG7BImhht32OFOYoD64T8x2N7WhoH8UKJZTAMAYzUvRD9J4bYAAAAASUVORK5CYII=',arrow:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AkLCiA4sJBNuAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABXSURBVDjLxZNBDoBACAPb/f+fZw+6hsNqBBLl3iGlxYA6M9ScdwAb2dQB4AtUtnADqd0gQIxUjwHcA3wX46OFTBNjAmcqo7o5b2FtD+JclTfiowd/f+METjMlD4iLdKcAAAAASUVORK5CYII='},f.canvas=document.getElementById('c'),f.c=f.canvas.getContext('2d'),f.bgcanvas=document.getElementById('bgc'),f.bgc=f.bgcanvas.getContext('2d'),f.icanvas=document.getElementById('ic'),f.ic=f.icanvas.getContext('2d'),f.health=p('health'),f.images={},f.Tiles){let r=new Image;r.src=f.Tiles[q],f.images[q]=r}window.addEventListener('load',function(){o=io({upgrade:!1,transports:['websocket']}),n()},!1),f.store.state=f.store.init()}(),'undefined'==typeof window&&function(){/**
 * Find opponents for a user
 * @param {User} user
 */function n(s){for(let t of r)// This actually does not work for g.Game.np === 1. But who wants to play alone?
if(s!==t&&// loggedUser counts for the total number
t.opponents.length<f.Game.np-1){for(let u of t.opponents)s.opponents.push(u),u.opponents.push(s);t.opponents.push(s),s.opponents.push(t),t.opponents.length===f.Game.np-1&&new p([t].concat(t.opponents)).start()}}/**
 * Remove user session
 * @param {User} user
 */function o(s){r.splice(r.indexOf(s),1)}function p(s){this.users=s}/**
 * Start new game
 *//**
 * User session class
 * @param {Socket} socket
 */function q(s){this.socket=s,this.game=null,this.alive=!0,this.opponents=[]}/**
 * Start new game
 * @param {Game} game
 * @param {User} opponent
 *//**
 * User sessions
 * @param {array} users
 */var r=[];p.prototype.start=function(){var s=f.Game.init(),t=this.users;// TODO get type of player from users
this.state=f.Game.prepareGame(s),this.alive=this.users.length,this.played=0,this.movements=[];for(let u=0;u<t.length;u++)t[u].start(this,u)},p.prototype.acceptMove=function(s,t){this.played=this.played+1;for(let u of s)this.movements.push(Object.assign({position:t},u));this.played===this.alive&&(this.played=0,this.move())},p.prototype.move=function(){var s=this.movements.sort((u,v)=>v.remainingTime-u.remainingTime),t=f.Game.computeMovements(this.state,s);this.state=t.state,this.movements=[];for(let u of this.users)u.alive&&this.state.players[u.position].s===f.Player.statuses.dead&&(this.alive=this.alive-1,u.die()),u.sendActions(t.actions)},p.prototype.ended=function(){return this.user1.guess!==GUESS_NO&&this.user2.guess!==GUESS_NO},q.prototype.start=function(s,t){this.game=s,this.position=t,this.socket.emit('start',JSON.stringify(Object.assign(s.state,{position:t})))},q.prototype.die=function(){this.alive=!1},q.prototype.move=function(s){this.alive&&this.game.acceptMove(s,this.position)},q.prototype.sendActions=function(s){this.socket.emit('actions',s)},q.prototype.end=function(){this.game=null,this.opponent=null,this.guess=GUESS_NO,this.socket.emit('end')},q.prototype.win=function(){this.socket.emit('win',this.opponent.guess)},q.prototype.lose=function(){this.socket.emit('lose',this.opponent.guess)},q.prototype.draw=function(){this.socket.emit('draw',this.opponent.guess)},module.exports=function(s){var t=new q(s);r.push(t),n(t),s.on('disconnect',function(){o(t)}),s.on('move',function(u){t.move(u)})}}()})();